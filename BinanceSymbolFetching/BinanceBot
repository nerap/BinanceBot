#!/usr/bin/python3

import os
import time
import json
import _thread
import sqlalchemy
import sys, getopt
import pandas as pd
import requests as rq
from datetime import datetime

SQLite_dir = 'SQLiteDB'
bot = sys.argv[0]
url_binance_ticker_price = "https://api.binance.com/api/v3/ticker/price?symbol="

# Making sure that the symbol in the configuration file is valid for Binance

def parse_symbol(symbol):
    res = rq.get(url_binance_ticker_price + symbol).json()
    if 'msg' in res:
        print(symbol + ' is not valid for BinanceBot check your configuration file')
        print(res["msg"])
        print("Return Code : " + str(res["code"]))
        sys.exit(1)
    elif symbol == "":
        print(symbol + ' is not valid for BinanceBot check your configuration file')
        sys.exit(1)
    return symbol

# Parsing all symbols in the configuration file with JSON format

def parse_config_file(config_file):
    if config_file == '':
        print ("Error: configuration file missing")
        sys.exit(1)
    try:
        conf_fd = open(config_file,)
    except IOError:
        print ("Error: can't open " + config_file)
        sys.exit(1)
    try:
        config_object = json.load(conf_fd)
    except ValueError as e:
        print (config_file + " is not a valid config file")
        sys.exit(1)
    if 'symbols' in config_object:
        if len(config_object['symbols']) <= 0:
            print("Error: your configuration file is empty")
            sys.exit(1)
        if 'symbol' in config_object['symbols'][0]:
            symbols = []
    else:
        print("Error: configuration file doesn't have the right key")
        sys.exit(1)
    for symbol in config_object['symbols']:
        symbols.append(parse_symbol(symbol['symbol']))
    for i in range(len(symbols)):
        for j in range(len(symbols)):
            if symbols[i] == symbols[j] and i != j:
                print("Error: duplicated symbol " + symbols[i] + " in configuration file")
                sys.exit(1)
    return symbols

# Taking all arguments of the program to parse -h and -f options.
# Making sure that the use is sending valid input and valid symbol.

def parse_entry(argv):
    config_file = ""
    try:
        opts, args = getopt.getopt(argv, "hf:", ["help", "file="])
    except getopt.GetoptError:
        print ('python3 ' + bot + ' -f <file> or --file=<file>')
        print ('python3 ' + bot + ' -h or --help')
        sys.exit(1)
    if len(opts) <= 0:
        print ('python3 ' + bot + ' -f <file> or --file=<file>')
        print ('python3 ' + bot + ' -h or --help')
        sys.exit(1)
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            print ('python3 ' + bot + ' -f <file> or --file=<file>')
            sys.exit(0)
        elif opt in ('-f', '--file'):
            config_file = arg
    return parse_config_file(config_file)

# Reformate the json response "res" to a pandas DataFrame 

def create_frame(res):
    df = pd.DataFrame([{"symbol": res["symbol"],
                        "datetime": int(time.time()),
                        "price": float(res["price"]) }])
    df.columns = ['Symbol', 'Time', 'Price']
    df.Price = df.Price.astype(float)
    df.Time = pd.to_datetime(int(time.time() * 1000), unit="ms")
    return (df)

# Transforming DataFrame into SQLite data

def storing_price_symbol(symbol):
    engine = sqlalchemy.create_engine('sqlite:///SQLiteDB/' + symbol + 'stream.db')
    while True:
        res = rq.get("https://api.binance.com/api/v3/ticker/price?symbol=" + symbol).json()
        data_frame = create_frame(res)
        data_frame.to_sql(symbol, engine, if_exists='append', index=False)
        print(data_frame)

# Starting a Thread for each symbol in the configuration file

def fetching_symbols(symbols):
    if not os.path.exists(SQLite_dir):
        os.makedirs(SQLite_dir)
    else:
        for f in os.listdir(SQLite_dir):
            os.remove(os.path.join(SQLite_dir, f))
    for symbol in symbols:
        try:
            _thread.start_new_thread( storing_price_symbol, (symbol , ))
        except ValueError as e:
            print('Error: Thread unable to start')
            sys.exit(1)
    while True:
        time.sleep(0.100)
        pass
    print('Every thread is working')

if __name__ == "__main__":
    symbols = parse_entry(sys.argv[1:])
    fetching_symbols(symbols)
